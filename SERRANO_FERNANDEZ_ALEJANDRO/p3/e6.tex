\centering
\includegraphics[width=0.9\linewidth]{graphic.png}

\begin{lstlisting}
cronometro c1, c2, c3, c4;                
long int r1 = 0,r2 = 0,r3 = 0,r4 = 0;
const double e_abs = 0.01, // Maximo error absoluto cometido.
	e_rel = 0.001; // Maximo error relativo aceptado.

c1.activar();
do {	

    colocado = false;    
    //Ordenamos para obtener siempre los de mayor valor
    celdasCandidatas2 = celdasCandidatas;	    

    
    currentDefense = defenses.begin();
 
    //Vamos colocando las defensas restantes y comprobando aquellas que sean factibles
    while(currentDefense != defenses.end()) 
    {
    	colocado = false;
    	
    	while(!celdasCandidatas2.empty() && !colocado)	    	
    	{
    		sin_ordenacion(celdasCandidatas2);
    		
	    	if(factible(celdasCandidatas2.back(), freeCells, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses, currentDefense))
	    	{
	    		(*currentDefense)->position.x = (celdasCandidatas2.back().row_ * cellWidth) +  (0.5f * cellWidth);
    			(*currentDefense)->position.y = (celdasCandidatas2.back().col_ * cellHeight) + (cellHeight * 0.5f);
	    		colocado = true;
	     	}
	    	celdasCandidatas2.pop_back();
    	}    	
    	currentDefense++;
    }  	
	
    ++r1;
    
} while(c1.tiempo() <  e_abs / e_rel + e_abs);    
c1.parar();    





c2.activar();
do {	

    colocado = false;    
    //Ordenamos para obtener siempre los de mayor valor
    celdasCandidatas2 = celdasCandidatas;
	    

    ordenacion_fusion(celdasCandidatas2, 0, celdasCandidatas2.size()-1);

    
    currentDefense = defenses.begin();
 
    //Vamos colocando las defensas restantes y comprobando aquellas que sean factibles
    while(currentDefense != defenses.end()) 
    {
    	colocado = false;
    	
    	while(!celdasCandidatas2.empty() && !colocado)
    	{
	    	if(factible(celdasCandidatas2.back(), freeCells, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses, currentDefense))
	    	{
	    		(*currentDefense)->position.x = (celdasCandidatas2.back().row_ * cellWidth) +  (0.5f * cellWidth);
    			(*currentDefense)->position.y = (celdasCandidatas2.back().col_ * cellHeight) + (cellHeight * 0.5f);
	    		colocado = true;
	     	}
	    	celdasCandidatas2.pop_back();
    	}    	
    	currentDefense++;
    }  	
	
    ++r2;
    
} while(c2.tiempo() <  e_abs / e_rel + e_abs);    
c2.parar(); 




c3.activar();
do {	

    colocado = false;    
    //Ordenamos para obtener siempre los de mayor valor
    celdasCandidatas2 = celdasCandidatas;
    
    
    ordenacion_rapida(celdasCandidatas2, 0, celdasCandidatas.size()-1);
    currentDefense = defenses.begin();
 
    //Vamos colocando las defensas restantes y comprobando aquellas que sean factibles
    while(currentDefense != defenses.end()) 
    {
    	colocado = false;
    	
    	while(!celdasCandidatas2.empty() && !colocado)
    	{
	    	if(factible(celdasCandidatas2.back(), freeCells, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses, currentDefense))
	    	{
	    		(*currentDefense)->position.x = (celdasCandidatas2.back().row_ * cellWidth) +  (0.5f * cellWidth);
    			(*currentDefense)->position.y = (celdasCandidatas2.back().col_ * cellHeight) + (cellHeight * 0.5f);
	    		colocado = true;
	     	}
	    	celdasCandidatas2.pop_back();
    	}    	
    	currentDefense++;
    }  	
	
    ++r3;
    
} while(c3.tiempo() <  e_abs / e_rel + e_abs);    
c3.parar(); 




c4.activar();
do {	

    colocado = false;    
    //Ordenamos para obtener siempre los de mayor valor
    celdasCandidatas2 = celdasCandidatas;
    

    ordenacion_monticulo(celdasCandidatas2);
    currentDefense = defenses.begin();
 
    //Vamos colocando las defensas restantes y comprobando aquellas que sean factibles
    while(currentDefense != defenses.end()) 
    {
    	colocado = false;
    	
    	while(!celdasCandidatas2.empty() && !colocado)
    	{
	    	if(factible(celdasCandidatas2.back(), freeCells, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses, currentDefense))
	    	{
	    		(*currentDefense)->position.x = (celdasCandidatas2.back().row_ * cellWidth) +  (0.5f * cellWidth);
    			(*currentDefense)->position.y = (celdasCandidatas2.back().col_ * cellHeight) + (cellHeight * 0.5f);
	    		colocado = true;
	     	}
	    	celdasCandidatas2.pop_back();
    	}    	
    	currentDefense++;
    }  	
	
    ++r4;
    
} while(c4.tiempo() <  e_abs / e_rel + e_abs);    
c4.parar();   


std::cout << (nCellsWidth * nCellsHeight) << '\t' << c1.tiempo() / r1 << '\t' << c2.tiempo() / r2 << '\t' << c3.tiempo() / r3 << '\t' << c4.tiempo() / r4 << std::endl;
\end{lstlisting}
